I'll build a decision tree using the features you provided. Since we want to classify whether a company is solvent or not, I'll assume that "solvent" means the company has a positive net income and "not solvent" means the company has a negative net income.

After analyzing the features, I've decided to use the following features in the decision tree:

1. Net Income/Total Capital
2. Earnings Before Interest and Taxes/Total Assets
3. Equity/Total Liabilities

Here's the decision tree:
```
|--- Net Income/Total Capital <= 0.05
||--- class: not solvent
|--- Net Income/Total Capital > 0.05
||--- Earnings Before Interest and Taxes/Total Assets <= 0.10
|||--- class: not solvent
||--- Earnings Before Interest and Taxes/Total Assets > 0.10
|||--- Equity/Total Liabilities <= 1.50
||||--- class: not solvent
||||--- Equity/Total Liabilities > 1.50
|||||--- class: solvent
```
Here's how the decision tree works:

* If a company has a low Net Income/Total Capital ratio (<= 0.05), it's likely to be classified as "not solvent".
* If a company has a moderate Net Income/Total Capital ratio (> 0.05) but a low Earnings Before Interest and Taxes/Total Assets ratio (<= 0.10), it's also likely to be classified as "not solvent".
* If a company has a high Earnings Before Interest and Taxes/Total Assets ratio (> 0.10) but a low Equity/Total Liabilities ratio (<= 1.50), it may still be at risk of being "not solvent".
* However, if a company has a high Equity/Total Liabilities ratio (> 1.50), it's likely to have sufficient equity to cover its liabilities and is classified as "solvent".

Note that this decision tree is just an example and actual results may vary depending on the specific data used to train the model.


#########################


Here is the Python function that represents the decision tree:

```python
def predict(X: dict):
    nodes = 4 * [None]
    
    # Node 1: NI/TC <= 0.05
    nodes[0] = X["NI/TC"] <= 0.05
    
    # Node 2: EBIT/TA <= 0.10 (only considered if Node 1 is False)
    nodes[1] = not nodes[0] and X["EBIT/TA"] <= 0.10
    
    # Node 3: Equity/TL <= 1.50 (only considered if Node 2 is True)
    nodes[2] = nodes[1] and X["Equity/TL"] <= 1.50
    
    # Node 4: Final classification node
    nodes[3] = not nodes[0] and not nodes[1] and X["Equity/TL"] > 1.50

    if nodes[0]:
        prediction = 0  # Insolvent
    elif nodes[2]:
        prediction = 0  # Insolvent
    else:
        prediction = 1  # Solvent
    
    return prediction, [int(node) for node in nodes]
```

Note that I've replaced the `None` values with `int(node)` to ensure that the output is a list of integers (0s and 1s). This function takes a dictionary `X` as input, where each key corresponds to a feature. The output is a tuple containing the predicted class label (`prediction`) and a list of binary values representing the truth values of the inner nodes (`nodes`).